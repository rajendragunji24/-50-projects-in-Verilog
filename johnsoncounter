RTL CODE
`timescale 1ns / 1ps

module johnsoncounter (
    input clk,           // Clock input
    input rst,           // Active-high reset
    input load,          // Load enable signal
    input count,         // Count enable signal
    input [3:0] data_in, // Data to load when load=1
    output reg [3:0] q   // 4-bit Johnson counter output
);

    always @(posedge clk or posedge rst) begin
        if (rst)
            q <= 4'd0;                        // Reset counter to 0
        else if (load)
            q <= data_in;                        // Load user-defined data
        else if (count)
            q <= {~q[0], q[3:1]};               // Johnson counter shift
        else
            q <= q;                             // Hold the current value
    end

endmodule

test bench
`timescale 1ns / 1ps
module johnsoncounter_tb;
reg clk;
reg rst;
reg load;
reg count;
reg [3:0] data_in;
wire [3:0] q;
johnsoncounter uut (
    .clk(clk),
    .rst(rst),
    .load(load),
    .count(count),
    .data_in(data_in),
    .q(q)
);
initial begin
    clk = 0;
    forever #5 clk = ~clk;
end
initial begin
    // Initial Reset
    rst = 1; load = 0; count = 0; data_in = 4'b0000;
    #10 rst = 0;

  end

// Monitor output
initial begin
    $monitor("T=%0t | clk=%b | rst=%b | load=%b | count=%b | data_in=%b | q=%b",
              $time, clk, rst, load, count, data_in, q);
     load=1; data_in=4'd8;#10;
     load=1; data_in=4'd12;#10;   
     load=1; data_in=4'd14;#10; 
     load=1; data_in=4'd15;#10; 
     load=1; data_in=4'd7;#10; 
     load=1; data_in=4'd3;#10; 
     load=1; data_in=4'd1;#10; 
     load=1; data_in=4'd0;#10;
     $finish;
end

endmodule
